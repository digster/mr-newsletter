# Work Summary - 2026-01-28

## Fix Desktop Mode Restart Loop

### Problem
The app was continuously restarting in desktop mode (every 1-2 seconds) with "App session started" logged repeatedly (~100+ times in 10 seconds).

### Root Cause Analysis

**Initial Hypothesis (Partially Correct):**
- `page.on_close` was being used incorrectly for desktop window close handling
- In Flet 0.80+, `page.on_close` is for web session expiration, not desktop window close

**Actual Root Cause (Discovered via Testing):**
The restart loop was caused by **port 8550** having stale state or caching issues in Flet's desktop view (Flutter client). Testing showed:
- Port 8550: 100+ sessions in 10 seconds (broken)
- Port 9550: 1 session (working)
- Port 9999: 1 session (working)

The Flet desktop client appears to cache connection state per-port. When a port was previously used with an unclean exit, subsequent connections enter a reconnection loop.

### Solution

**1. Changed default port from 8550 to 9550:**
- `src/config/settings.py`: Changed `flet_port` default to 9550
- `.env`: Updated `FLET_PORT=9550`

**2. Fixed window close handler for desktop mode:**
- Replaced `page.on_close` with `page.window.on_event`
- Added `page.window.prevent_close = True` to intercept close events
- Created `_on_window_event()` method that checks for `ft.WindowEventType.CLOSE`
- Properly calls `await self.shutdown()` then `await page.window.destroy()`

### Changes Made
**File: `src/config/settings.py`**
- Changed `flet_port` default from 8550 to 9550

**File: `.env`**
- Changed `FLET_PORT=8550` to `FLET_PORT=9550`

**File: `src/app.py`**
1. Replaced shutdown handler registration:
   - Added `page.window.prevent_close = True`
   - Set `page.window.on_event = self._on_window_event`

2. Added `_on_window_event()` async method:
   - Checks `e.type == ft.WindowEventType.CLOSE`
   - Runs shutdown, then destroys window

### Key Insights
- Port caching in Flet desktop view can cause restart loops
- `page.on_close` → Web session expiration (wrong for desktop)
- `page.window.on_event` → Actual window events (correct for desktop)
- Must set `prevent_close = True` to intercept close events

---

## Permanent Fix for Port Caching Issues

### Problem
The port change from 8550 to 6550 was a workaround, not a permanent fix. The restart loop could recur if:
- The app crashes without proper cleanup
- Force quit from macOS Dock
- Kill -9 or SIGKILL
- Hot-reload in development
- Network instability

### Solution: Dynamic Port Allocation + Signal Handlers

**1. Dynamic Port Allocation:**
- Changed `flet_port` default from 6550 to 0
- Port 0 tells the OS to assign any available free port
- Each launch gets a fresh port with no cached state

**2. Robust Signal Handlers:**
- Added SIGTERM handler (kill command, system shutdown)
- Added SIGHUP handler (terminal close, SSH disconnect)
- Ensures cleanup runs even when terminated by signals

### Changes Made

**File: `src/config/settings.py`**
- Changed `flet_port` default from 6550 to 0 (dynamic allocation)

**File: `src/main.py`**
- Added `signal` import
- Added `setup_signal_handlers()` function with SIGTERM/SIGHUP handlers
- Called signal handlers in `run()` before starting app

**File: `.env`**
- Commented out FLET_PORT to use dynamic allocation

**File: `.env.example`**
- Updated to show dynamic port as default

### Technical Details
- `get_free_tcp_port()` in Flet finds unused ephemeral ports (49152-65535)
- OS-level TCP TIME_WAIT (2×MSL = 30 seconds on macOS) no longer affects restarts
- Signal handlers call `sys.exit(0)` which triggers atexit handlers for cleanup

---

## Fix Theme Persistence Bug

### Problem
When a theme was applied, it worked correctly. However, after app restart:
- The chosen theme remained **selected** in the Settings UI (database stored it correctly)
- But the actual **styling didn't apply** - it defaulted to the built-in default theme

### Root Cause
In `src/app.py` lines 51-53, the app set default themes during initialization:
```python
self.page.theme = AppTheme.get_light_theme()
self.page.dark_theme = AppTheme.get_dark_theme()
```
But the saved theme from the database was never loaded and applied. The global color cache (`_active_light_colors`/`_active_dark_colors` in `design_tokens.py`) remained `None`.

### Solution
Added a new method `_load_saved_theme()` to `NewsletterApp` in `src/app.py` that:
1. Reads `active_theme` from `UserSettings` database
2. Loads the theme file via `ThemeService.load_theme()`
3. Applies colors via `ThemeService.apply_theme()` (sets global cache)
4. Updates `page.theme` and `page.dark_theme` with Flet theme objects
5. Sets `page.theme_mode` based on theme's base preference (light/dark)

Called this method in `initialize()` after database init but before services.

### Edge Cases Handled
- Theme file deleted: Falls back to default.json, updates database
- Default theme selected: Early return (already applied)
- Corrupted theme file: Falls back gracefully, logs warning
- New installation: Default theme applied (no change needed)

### Files Modified
- `src/app.py` - Added `_load_saved_theme()` method and call in `initialize()`

### Testing
- All 286 unit tests pass
- Manual testing confirmed theme loads correctly on app restart
- Log output shows: "Applied theme: Solarized Light" and "Loaded saved theme: Solarized Light"
